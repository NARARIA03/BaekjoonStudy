exp = input()

ary = []

# 숫자의 시작 자리를 기억하는 idx
num_start_idx = 0
# 문자열의 모둔 문자를 하나씩 방문한다
for i in range(len(exp)):
    # index == i 일때 문자가 연산자라면
    if exp[i] == "+" or exp[i] == "-":
        # 슬라이싱으로 숫자부분 잘라낸 뒤 int형으로 바꿔서 ary에 추가
        ary.append(int(exp[num_start_idx:i]))
        # 숫자의 시작 자리를 i 바로 다음 (연산자 바로 다음)으로 옮김
        num_start_idx = i + 1
        # 연산자도 ary에 추가
        ary.append(exp[i])
    # 마지막 숫자는 연산자로 걸러낼 수 없음 -> 만약 i가 마지막 인덱스라면 num_start_idx <=  < i + 1까지 슬라이싱해서 가져와야 함
    elif i == len(exp) - 1:
        ary.append(int(exp[num_start_idx : i + 1]))

flag = False
for i in range(0, len(ary)):
    # - 연산자를 만났다면, 연산자 이후 나오는 숫자들을 괄호로 묶어서 가능한 한 많은 덧셈을 최대한 뺄셈으로 만들어야 한다.
    #   ex) 5 - 4 + 3 + 2 - 1 --> 5 - (4 + 3 + 2) - 1
    if ary[i] == "-":
        flag = True
        continue  # 바로 아래 if flag문에 간섭하지 않기 위해 다음 회차로 바로 이동
    if flag:  # 만약 이전에 - 연산자를 만난 상태라면, 다시말해 괄호가 열려있다면
        # + 연산자는 - 연산자가 된다 (괄호 앞에 -가 있으므로)
        if ary[i] == "+":
            ary[i] = "-"
        # 만약 - 연산자를 다시 만났다면, 이 바로 앞 숫자에서 괄호를 닫아주어야 한다.
        elif ary[i] == "-":
            flag = False
            continue  # flag 관련 조건문 꼬이지 않도록 다음 회차로 이동

# 코드 이해를 위해 결과를 하나 적어두면...
# 5+10+15-20+30-40-50+30 입력
# 5 + 10 + 15 - (20 + 30) - 40 - (50 + 30)이 가장 최소값이 나오는 케이스다. (그리디 알고리즘)
# [5, "+", 10, "+", 15, "-", 20, "-", 30, "-", 40, "-", 50, "-", 30] 결과 배열 상태
# 다시말해, - 연산자를 만나면, 다시 - 연산자를 만나기 전까지 괄호로 묶어야 연산 결과가 최소로 나온다. (- 연산을 하는 값이 커지기 때문)
# 원리를 이해하기 위해 거창하게 적어뒀지만, - 연산자가 나온 뒤로 모든 연산자를 전부 - 연산자로 바꾼 것과 같다. 이게 가능한 이유는 다시 위 상세한 주석 읽어보면 될듯

sum = ary[0]
# 참고로 len(ary)는 항상 홀수이다. 가장 처음과 마지막은 반드시 숫자라고 했고, 연산기호 수는 숫자 수 - 1이기 때문이다.
for i in range(1, len(ary), 2):
    if ary[i] == "+":
        sum += ary[i + 1]
    elif ary[i] == "-":
        sum -= ary[i + 1]
print(sum)
